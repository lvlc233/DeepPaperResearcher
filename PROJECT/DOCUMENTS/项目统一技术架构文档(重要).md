# 项目统一技术架构文档 (Unified Technical Architecture)

> **版本**: v1.1
> **日期**: 2026-01-12
> **提交方**: BackendAgent
> **状态**: 正式 (Official)
> **说明**: 本文档作为项目开发的唯一技术事实来源 (Single Source of Truth)，消除了 Frontend、Backend 和 Agent 设计文档中的差异。已同步 v1.0 前端 API 需求。

---



## 1. 系统架构概览

采用 **前后端分离** + **Agent 编排** 的架构。

*   **前端**: Next.js 14 (App Router) + Zustand + Vercel AI SDK
*   **后端**: FastAPI + SQLModel + PostgreSQL (pgvector) + Arq (Async Tasks)
*   **Agent**: LangGraph + LangChain(1.1+的)->create_agent和中间件+deepagents

### 技术细节
*   统一任务模型为 Job（TOC/总结/脑图/解析均为 Job），前端只感知 jobId 与状态更新。
*   Job 幂等与去重：按 user_id + paper_id + task_type + params_hash + pipeline_version 生成幂等键，复用运行中/已完成任务。
*   Job 状态机：queued / running / blocked / succeeded / failed / canceled / expired，支持 progress 与 stage。
*   依赖与产物复用：解析产物作为上游 Job 产物供下游任务复用，避免重复解析。
*   SSE 断线重连策略：支持 Last-Event-ID、心跳间隔(5s)与超时回退到状态查询。
*   Token 生命周期与刷新策略：明确 access/refresh 有效期为(半天,7天)
*   文件与存储：上传大小与格式限制
*   重型计算和IO密集型任务（如 PDF 解析、OCR、向量化）。这些任务通过 `Arq` 异步队列执行，状态记录在 DB 中。
*   关于pdf上传,现在pdf有两种上传的类型:基于web的上传->存储web的file_url,基于本地的有两种方式分别是存储到本地,使用nginx进行代理,其代理的url就是file_url,并且要保持存储到对象存储的支持(后面再考虑吧),所以应该有三个部分的服务?接口?一个专门处理网络的,一个专门处理本地的,一个专门处理存储到对象存储中的。然后在pdf解析完成后,要持久化,再下次使用的时候可以直接读取解析后的结果。

---
## 前端技术选型和技术需求。
### 技术选型
| 模块 | 选型 | 理由 |
| :--- | :--- | :--- |
| **框架** | **Next.js 14+ (App Router)** | 官方推荐，天然支持 SSR/SSG，路由系统完善，便于 SEO 和首屏优化。 |
| **语言** | **TypeScript 5.x** | 强制类型安全，配合 strict 模式，减少运行时错误。 |
| **样式** | **TailwindCSS** | 原子化 CSS，开发效率高，配合 PostCSS 构建体积小。 |
| **组件库** | **Radix UI + 自建组件（Shadcn 风格）** | Headless UI + Tailwind 方案，组件实现可控，适配“视图/标注”等特殊交互。 |
| **图标** | **Lucide React** | 风格统一，轻量，Shadcn 默认推荐。 |
| **PDF 阅读** | **react-pdf + pdfjs-dist** | 浏览器端 PDF 渲染，叠加自研 Overlay 支持多视图标注。 |
| **图表** | **Reagraph** | 基于 React 的知识图谱可视化库，支持 Lasso 选择。 |
| **状态管理** | **Zustand** | 轻量、高性能，DevTools 支持好。 |
| **AI 交互** | **fetch + eventsource-parser（SSE）** | 当前以 SSE 流式接收 Token；已安装 `ai` 依赖，后续可切换为 Vercel AI SDK。 |
| **Markdown 渲染** | **react-markdown** | 渲染 AI 输出报告/笔记等富文本内容。 |
| **消息提示** | **Sonner** | 统一 Toast 提示，体验轻量。 |
| **请求发送** | **Axios（封装 request.ts）** | 统一 baseURL/超时、注入 Bearer Token、错误码与 401 处理。 |
| **SSE增强** | **@microsoft/fetch-event-source** | 默认的SSE没有办法在头中添加自定义的header，需要使用这个库来增强SSE的功能。还有post功能 |

## 前后端接口文档
通用前缀:`/api/v1`,以下路径皆省略前缀。所有的数据(除了SSE),其他的数据模型都用`{code:int,data:T,message:str}`进行包装,下面的内容仅包括`data: T`
鉴权 ：除 Auth 注册/登录/刷新外，全部要求 `Authorization: Bearer <access_token>`,user_id由jwt解析出来

成功时:code = 200
错误时:若为非下面的业务情况统一 code=50000
其他业务的错误码: 都是5位数。
HTTP status 按标准语义返回； code 永远是业务码 （401xx/50xxx/…），前端用 code 做业务分支，用 HTTP status 做通用处理/兜底。
统一的时间格式: ISO-8601
以下的模型明细仅供参考,注意转化为对应领域的语言进行实现
对外接口只出现 *Request/*Response ； *Model/*Entity/*Core 仅供内部复用，禁止直接作为 Response 字段类型引用（必须映射为对应 *Response/*ItemResponse ）。
命名与结构：把“基础模型”变成 Response 专用的 Item 建议统一一个套路：
- 单对象： XxxResponse
- 列表： XxxListResponse { items: List[XxxItemResponse] }
- 嵌套对象也用 ItemResponse 明确它是 DTO，不是 Domain

### 认证模块 (Auth): 401xx (后端ok)
需要提供标准 JWT 认证支持。
#### 接口列表
| Method | Path | Description | Payload/Params | Response |
| :--- | :--- | :--- | :--- | :--- |
| `POST` | `/auth/register` | 用户注册 | `RegisterRequest` | `UserPublicResponse` |
| `POST` | `/auth/login` | 用户登录 | `LoginRequest` | `LoginResponse` |
| `GET` | `/auth/refresh` | 刷新短 token | `refresh_token:str` | `TokenPairResponse` |

#### 模型明细
```python
class RegisterRequest(BaseModel):
    email: str # 用户邮箱(登录账号)
    password: str # 密码
    full_name: str # 用户全名/昵称
    # 验证码: TODO: 以后再补,现在不需要
    
class LoginRequest(BaseModel):
    email: str # 用户邮箱(登录账号)
    password: str # 密码
    remember_me: bool = False # 控制是否开启refresh_token

class UserPublicResponse(BaseModel):
    user_id: UUID # 用户全局唯一标识(UUID)
    email: str # 用户邮箱(登录账号)
    full_name: str # 用户全名/昵称
    is_active: bool # 账号是否激活(True:激活, False:禁用/删除)
    created_at: datetime # 账号创建时间
    settings: Settings #见下。设置那一块。

class TokenPairResponse(BaseModel):
    access_token: str # 访问token
    refresh_token: str|None = None # 刷新token

class LoginResponse(BaseModel):
    user_id: UUID # 用户全局唯一标识(UUID)
    email: str # 用户邮箱(登录账号)
    full_name: str # 用户全名/昵称
    is_active: bool # 账号是否激活(True:激活, False:禁用/删除)
    created_at: datetime # 账号创建时间
    settings: Settings 
    access_token: str # 访问token
    refresh_token: str|None = None # 刷新token

```

...

### 论文上传模块: 异常码:51xxx
支持论文上传
#### 接口列表
| Method | Path | Description | Payload/Params | Response |
| :--- | :--- | :--- | :--- | :--- |
| `POST` | `/papers/upload/web` | 直接上传网络上可以直接访问的pdf | `PapersUploadWebRequest` | `PapersUploadResponse[]` |
| `POST` | `/papers/upload/local` | 上传本地的pdf文件 |`multipart/form-data`,`PapersUploadLocalRequest` | `PapersUploadResponse[]` |
#### 模型明细
```python
class PapersUploadWebRequest(BaseModel):
    urls: list[str] # 论文的url列表,需要指向pdf
    collection_id: UUID|None = None #默认指向默认收藏夹

class PapersUploadLocalRequest(BaseModel):
    files: File[],
    collection_id: UUID|None = None #默认指向默认收藏夹

class PapersUploadResponse(BaseModel):
    paper_id: UUID        # 论文全局唯一标识(UUID). 本地上传的时候,会生成一个id,在数据库中保存的也是这个id,这个id将作为一个文件夹,在这个文件夹下存储实际的pdf。
    title: str # 论文标题
    status: Literal['processing','success','failed']  # 处理状态(PENDING/PROCESSING/COMPLETED/FAILED). 这里的状态仅表示上传,上传包括以下的步骤,1如果是local,写入本地,2.从传入的数据中解析出元信息(见下)->持久化到数据库中->都没有异常,才success,上传的时候不阻塞用户进行其他的事情。

```


### 收藏夹管理模块 (Papers): 异常码:52xxx (后端ok)
管理收藏夹
#### 接口列表
| Method | Path | Description | Payload/Params | Response |
| :--- | :--- | :--- | :--- | :--- |
| `GET` | `/collections` | 获取指定用户的所有收藏夹 |  | `List[CollectionResponse]` |
| `GET` | `/collections/{collection_id}` | 获取指定收藏夹的详情 |  | `CollectionDetailResponse` |
| `POST` | `/collections` | 创建收藏夹 | `CollectionCreateRequest` | `CollectionResponse` |
| `DELETE` | `/collections/{collection_id}` | 删除收藏夹 |  |  |
| `PATCH` | `/collections/{collection_id}` | 更新收藏夹名 |`new_name:str` |  |
| `DELETE` | `/collections/papers/{paper_id}` | 删除论文(删除相关资源并移除) |  |  |
| `PATCH` | `collections/{collection_id}/papers/move/{paper_id}` | 将一个论文迁移到另外一个收藏 |  |  |
#### 模型明细
```python
class CollectionResponse(BaseModel):
    collection_id: UUID # 收藏夹ID
    name: str # 收藏夹名称
    total: int # 收藏夹下的论文数量
class CollectionCreateRequest(BaseModel):
    name: str # 收藏夹名称

class PaperMetaInCollection(BaseModel): # 这个是DTO
    paper_id: UUID # 论文全局唯一标识(UUID)
    title: str # 论文标题
    authors: List[str] # 作者列表(JSON数组)
    summary: str|None = None # 论文摘要原文
    published_at: datetime|None = None # 上传/创建时间
    source: str # 文件来源类型(如arXiv、PDF等)
    tags: List[str] # 标签(类型)
    references_number: int|None = None  # 引用数量

class CollectionDetailResponse(BaseModel):
    items: List[PaperMetaInCollection]

```


### 搜索模块 (Search): 异常码:53xxx
#### 接口列表
| Method | Path | Description | Payload/Params | Response |
| :--- | :--- | :--- | :--- | :--- |
| `POST` | `/search` | 获取的论文列表 | `SearchRequest` | `SearchedPaperMetaResponse` |
| `POST` | `/search/ai/stream` | 获取 AI 搜索论文列表 | `{query: str}` | `SSE` |
#### 模型明细
```python
# 分页搜索: 搜索条件的设计分开(这里的设置就是,搜索来源)
class SearchRequest(BaseModel):
    query:str
    page: int
    limit: int

class SearchedPaperMetaResponse(BaseModel):
    items: List[PaperMeta]
    total:int

# 也不知道要什么就想这样子定吧,这个可以后面调
class PaperMeta(BaseModel):
    paper_id: UUID # 论文全局唯一标识(UUID)
    url: str # 文件访问URL(可选). 可访问链接,如果是网络的,可以是直接web中的url,如果本地上传上来的, 那么就是后端提供的代理的url
    title: str # 论文标题
    authors: List[str] # 作者列表(JSON数组)
    summary: str|None = None # 论文摘要原文
    published_at: datetime|None = None # 上传/创建时间
    source: str # 文件来源类型(如arXiv、PDF等)
    tags: List[str] # 标签(类型)
    references_number: int|None = None  # 引用数量

SSE Event:
    连接:{id:paper_id,event:PaperAISearchStart}
    推送:{id:paper_id,event:PaperAISearch,data:List[PaperMeta]} 
    结束:{id:paper_id,event:PaperAISearchEnd,data:total:int  or str(异常信息)} 


    
```



### 阅读模块(Read)
把“读取结果”和“触发耗时任务”拆开：读取用 GET；耗时任务统一为 Job，通过 jobId 订阅 SSE 或查询状态。
#### 只读接口（GET）: 异常码:54xxx (后端ok)
| Method | Path | Description | Payload/Params | Response |
| :--- | :--- | :--- | :--- | :--- |
| `GET` | `/papers/{paper_id}/meta` | 获取论文 | | `PaperReaderMetaResponse ` |
| `GET` | `/papers/{paper_id}/toc` | 获取论文目录 | | `TocResponse` |
| `GET` | `/papers/{paper_id}/views` | 获取论文视图 | | `List[ViewResponse]` |
| `GET` | `/papers/{paper_id}/notes` | 获取论文笔记 | | `NoteMetaResponse` |
| `GET` | `/papers/{paper_id}/notes/{note_id}` | 获取笔记内容 | | `NoteResponse` |
| `GET` | `/papers/{paper_id}/ai/summary` | 获取论文AI总结 | | `AISummaryResponse` |
| `GET` | `/papers/{paper_id}/ai/mind_map` | 获取论文AI脑图 | | `MindMapResponse` |
| `GET` | `/papers/{paper_id}/ai/history` | 获取论文AI历史 | | `List[RecordResponse]` |
| `GET` | `/papers/{paper_id}/ai/record/{record_id}` | 获取AI阅读记录 | | `MessageResponse` |
| `GET `| `/papers/{paper_id}/jobs` | 获取当前论文处理任务 | | `JobListResponse` |
#### 模型明细
```python
class Toc(BaseModel):
    items: List[TocItem] # 目录项

class TocItem(BaseModel):
    title: str # 目录项标题
    page: int # 目录项对应的页码

class View(BaseModel):
    view_id: UUID # 图层ID
    name: str # 图层名称
    enable: bool # 是否可见
    annotations: List[Annotation] # 视图注解

class Annotation(BaseModel):
    annotation_id: UUID # 标注ID
    type: Literal['highlight','translation','note'] # 标注类型(highlight/note/translate)
    rect:Rect # 标注区域坐标(JSON数组)
    content: str # 标注内容(笔记/翻译结果)
    color: str # 标注颜色(Hex/RGB)


class Rect(BaseModel):
    x: float # 矩形左上角的 x 坐标
    y: float # 矩形左上角的 y 坐标
    width: float # 矩形的宽度
    height: float # 矩形的高度
    page_index: int # 矩形所在的页码索引 (从 0 开始)

class NoteMeta(BaseModel):
    note_id: UUID # 笔记id
    title: str # 笔记标题
    page: int|None=None # 笔记对应的页码,默认为空
    created_at: datetime # 创建的时间
    

class AISummary(BaseModel):
    summary_config: Dict[str, str] # 论文AI总结, 键为总结的类型(和设置项相关), 值为目录项对应的总结

class MindMap(BaseModel):
    nodes: List[MindMapNode] # 节点列表
    edges: List[MindMapEdge] # 边列表

class MindMapNode(BaseModel):
    id: str # 节点id
    text: str # 节点文本
    type: str|None=None # 节点类型(可选)
    meta: Dict[str, str]|None=None # 节点元数据(可选)

class MindMapEdge(BaseModel):
    from_id: str # 边的起始节点id
    to_id: str # 边的结束节点id
    label: str|None=None # 边的标签(可选)



class Record(BaseModel):
    record_id: UUID # 记录id
    title:str # 对话记录的标题
    created_at:datetime #创建时间
    updated_at:datetime|None=None #更新时间

class Message(BaseModel):
    message_id: UUID # 消息id
    type: Literal['HUMAN','AI','TOOL_CALL','TOOL_RESPONSE'] # 消息类型[HUMAN,AI,TOOL_CALL,TOOL_RESPONSE]
    context:str # 消息内容 
    created_at:datetime #发送时间

class Job(BaseModel):
    job_id: UUID # 作业ID
    type: Literal['toc','summary','mind_map','deep_research','chat'] # 作业类型(search/paper_chat/summary/mindmap/deep_research)
    status: Literal['queued','running','blocked','succeeded','failed','canceled','expired'] # 作业状态(queued/running/blocked/succeeded/failed/canceled/expired)
    progress: float|None=None # 作业进度(0-100). 任务进度(0~1)
    stage: str|None=None # 作业当前阶段
    result: JobResult|None=None # 结果引用. 任务完成后的结果
    error: str|None=None # 错误信息. 任务失败后的错误信息
    created_at: datetime # 创建时间
    end_at: datetime|None=None # 完成时间. 结束时间 完成或失败

class JobCreateRequest(BaseModel):
    type: Literal['toc','summary','mind_map','deep_research','chat']
    record_id: UUID|None=None
    message: str|None=None
    options: Dict[str, Any]|None=None

class JobResponse(BaseModel):
    job: Job

JobResult:
    toc: Toc
    summary: AISummary
    mind_map: MindMap
    chat: List[Message]
    deep_research: List[Message]

class PaperReaderMetaResponse(BaseModel):
    paper_id: UUID # 论文全局唯一标识(UUID)
    url: str # 文件访问URL(可选). 可访问链接,如果是网络的,可以是直接web中的url,如果本地上传上来的, 那么就是后端提供的代理的url
    summary: AISummary|None=None # 论文AI总结
    toc: Toc|None=None # 论文目录结构(TOC). 论文目录: 目录在没解析出来的时候,为空,解析出来了,则返回目录
    views: List[View] # 论文视图
    notes: List[NoteMeta] # 论文笔记
    mind_map: MindMap|None=None # 论文AI脑图. 脑图在没解析出来的时候,为空,解析出来了,则返回脑图
    history: List[Record] # 论文AI历史记录
    jobs: List[Job] # 关联任务列表

class TocResponse(BaseModel):
    items: List[TocItem] # 目录项

class ViewResponse(BaseModel):
    view_id: UUID # 视图id
    name: str # 视图名
    enable: bool # 开启状态

class AnnotationResponse(BaseModel):
    items:List[Annotation] # 视图注解
class NoteMetaResponse(BaseModel): 
    items:List[NoteMeta]

class NoteResponse(BaseModel):
    note_id: UUID # 笔记ID
    title: str # 笔记标题
    page: int|None=None # 笔记对应的页码,默认为空
    created_at: datetime # 创建时间
    content: str # 笔记内容(Markdown)


class AISummaryResponse(BaseModel): 
    summary_config: Dict[str, str] # 论文AI总结, 键为总结的类型(和设置项相关), 值为目录项对应的总结
    
class MindMapResponse(BaseModel):
    nodes: List[MindMapNode] # 节点列表
    edges: List[MindMapEdge] # 边列表

class RecordResponse(BaseModel):
    record_id: UUID # 记录id
    title:str # 对话记录的标题
    created_at:datetime #创建时间
    updated_at:datetime|None=None #更新时间

class MessageResponse(BaseModel):
    items:List[Message] # 消息记录

class JobListResponse(BaseModel):
    items:List[Job] # 该论文的所有任务。

```




#### Job 接口（POST/GET，通常返回 SSE） 异常码:55xxx
| Method | Path | Description | Payload/Params | Response |
| :--- | :--- | :--- | :--- | :--- |
| `POST` | `/papers/{paper_id}/jobs` | 创建任务 | `JobCreateRequest` | `JobResponse` |
| `GET` | `/jobs/{job_id}` | 获取任务状态 |  | `JobResponse` |
| `GET` | `/jobs/{job_id}/events` | 订阅任务 SSE |  | `SSE` |
#### SSE 通用规范
1. SSE 响应头为 `Content-Type: text/event-stream; charset=utf-8`
2. 每条事件包含 `id`、`event`、`data` 三个字段，`data` 为 JSON 字符串
3. `data` 统一包裹为以下结构

```python
SSEDataEnvelope:
    code: int
    message: str
    state: Literal['start','progress','end','error']
    payload: Any|None

JobEventPayload:
    job_id: UUID
    type: Literal['toc','summary','mind_map','deep_research','chat']
    status: Literal['queued','running','blocked','succeeded','failed','canceled','expired']
    progress: float|None=None
    stage: str|None=None
    result: JobResult|None=None
    error: str|None=None
```

#### SSE 事件定义
```python
Job SSE:
    JobStart: payload: JobEventPayload
    JobProgress: payload: JobEventPayload
    JobEnd: payload: JobEventPayload
    JobError: payload: JobEventPayload
```

#### 视图与标注模块(View) 异常码:56xxx (ok)
| Method | Path | Description | Payload/Params | Response |
| :--- | :--- | :--- | :--- | :--- |
| `POST` | `/papers/{paper_id}/views` | 创建视图 |`name:str` | `ViewResponse` |
| `PATCH` | `/papers/{paper_id}/views/{view_id}/rename` | 重命名视图 |`name:str` | |
| `PATCH` | `/papers/{paper_id}/views/{view_id}/enable` | 启用/关闭视图 |`enable:bool` | |
| `DELETE` | `/papers/{paper_id}/views/{view_id}` | 删除视图 |  |  |
| `GET` | `/papers/{paper_id}/views/{view_id}/annotations` | 获取视图注解 | | `AnnotationResponse` |
| `POST` | `/papers/{paper_id}/views/{view_id}/annotations` | 对论文进行标注 | `AnnotationRequest` | |
| `DELETE` | `/papers/{paper_id}/views/{view_id}/annotations/{annotation_id}` | 删除标注 |  |  |
| `PUT` | `/papers/{paper_id}/views/{view_id}/annotations/{annotation_id}` | 修改标注 | `AnnotationRequest` |  |

#### 模型明细
```python

class AnnotationRequest(BaseModel):
    type: Literal['highlight','translation','note'] # 注解类型[高光,翻译,随笔内容]
    rect:Rect # 标注区域的几何坐标 
    content: str # 注解内容[随笔内容,翻译内容]
    color: str # RGB/Hex

```

### 用户设置模块(Settings): 异常码:57xxx (ok) 
| Method | Path | Description | Payload/Params | Response |
| :--- | :--- | :--- | :--- | :--- |
| `GET` | `/settings/search/sources` | 获取搜索来源 | | `SourceSettingsResponse` |
| `POST` | `/settings/search/sources` | 添加搜索来源 | |`AddSourceSettingsRequest`|  |
| `PATCH` | `/settings/search/sources/{source_id}` | 更新搜索来源 |`AddSourceSettingsRequest` |  |
| `DELETE` | `/settings/search/sources/{source_id}` | 删除搜索源 |  |  |
| `GET` | `/settings/search/ai` | 获取 AI 搜索设置 | | `AISearchSettingsResponse` |
| `PUT` | `/settings/search/ai` | 更新 AI 搜索设置 | `AISearchSettingsRequest` |  |
| `GET` | `/settings/reader/ai` | 获取 AI 阅读设置 | | `AIReaderSettingsResponse` |
| `PUT` | `/settings/reader/ai` | 更新 AI 阅读设置 | `AIReaderSettingsRequest` |  |
| `GET` | `/settings/system` | 获取系统设置 | | `SystemSettingsResponse` |
| `PUT` | `/settings/system` | 更新系统设置 | `SystemSettingsRequest` |  |

```python
class SourceSettings(BaseModel):
    name: str
    type: Literal['web','local'] # web|local
    source: str # url or collection_id
    enable: bool = True

class AddSourceSettingsRequest(BaseModel):
    name: str
    type: Literal['web','local'] # web|local
    source: str # url or collection_id
    enable: bool = True

class SourceSettingsResponse(BaseModel):
    items:List[SourceSettings]

# SourceSettings会同样影响AI搜索
class AISearchSettings(BaseModel):
    llm_name: str # 模型名
    provider: str # 供应商
    api_key: str # API 密钥
    base_url: str # base_url
    search_limit:int # 搜索数量上限
    search_loop:int # 搜索轮次上限
    ai_summary_enable: bool #是否开启AI搜索
    search_deep: Literal['shallow','standard','deep'] # 搜索深度[浅(标题),标准(包括摘要),深(包括正文)]
    search_preferences: Literal['latest','relevant','mixed'] # 搜索偏好[最新,相关,综合(用于引导模型搜索的评分判断依据)]
    search_date_max: date # 搜索时间上限
    search_date_min: date # 搜索时间下限

class AISearchSettingsRequest(BaseModel):
    llm_name: str # 模型名
    provider: str # 供应商
    api_key: str # API 密钥
    base_url: str # base_url
    search_limit:int # 搜索数量上限
    search_loop:int # 搜索轮次上限
    ai_summary_enable: bool #是否开启AI搜索
    search_deep: Literal['shallow','standard','deep'] # 搜索深度[浅(标题),标准(包括摘要),深(包括正文)]
    search_preferences: Literal['latest','relevant','mixed'] # 搜索偏好[最新,相关,综合(用于引导模型搜索的评分判断依据)]
    search_date_max: date # 搜索时间上限
    search_date_min: date # 搜索时间下限

class AISearchSettingsResponse(BaseModel):
    llm_name: str # 模型名
    provider: str # 供应商
    api_key: str # API 密钥,掩盖后的字符串
    base_url: str # base_url
    search_limit:int # 搜索数量上限
    search_loop:int # 搜索轮次上限
    ai_summary_enable: bool #是否开启AI搜索
    search_deep: Literal['shallow','standard','deep'] # 搜索深度[浅(标题),标准(包括摘要),深(包括正文)]
    search_preferences: Literal['latest','relevant','mixed'] # 搜索偏好[最新,相关,综合(用于引导模型搜索的评分判断依据)]
    search_date_max: date # 搜索时间上限
    search_date_min: date # 搜索时间下限

# TODO: 得思考一个问题就是一个系统中有多个Agent,每个Agent都有独立的设置项的时候应该怎么设计呢?
class AIReaderSettings(BaseModel):
    type: Literal['deep_research','chat','summary','mind_map'] # 配置类型 :[深度研究,chat,总结,脑图]
    llm_name: str # 模型名
    provider: str # 供应商
    api_key: str # API 密钥
    base_url: str # base_url
    config:dict# 其他配置内容 
    """
    deepResearch的配置: deep_loop: int # 研究深度(深度上限。) 
    """


class AIReaderSettingsRequest(BaseModel):
   items:List[AIReaderSettings]
class AIReaderSettingsResponse(BaseModel):
    items:List[AIReaderSettings] # 这里的api_key是加密的



class SystemSettings(BaseModel):
    system_colour: Literal['light','dark'] # 系统颜色 明亮|暗黑

class SystemSettingsRequest(BaseModel):
    system_colour: Literal['light','dark'] # 系统颜色 明亮|暗黑
class SystemSettingsResponse(BaseModel):
    system_colour: Literal['light','dark'] # 系统颜色 明亮|暗黑

class Settings(BaseModel):
    source_settings: List[SourceSettings]
    ai_search_settings: AISearchSettings
    ai_reader_settings: List[AIReaderSettings]
    system_settings:SystemSettings

```

## 统一数据库设计 (Database Schema)

以当前后端实现为基线，并加入统一 Job 模型、去重、版本化与可观测字段。

### 2.1 用户与鉴权 (Users)
```python
class User(SQLModel, table=True):
    __tablename__ = "users"
    id: UUID = Field(default_factory=uuid4, primary_key=True)
    email: str = Field(unique=True, index=True)
    hashed_password: str
    full_name: Optional[str] = None
    is_active: bool = Field(default=True)
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)
```

### 2.2 论文 (Papers)
```python
class PaperStatus(str, Enum):
    PENDING = "pending"
    PROCESSING = "processing"
    COMPLETED = "completed"
    FAILED = "failed"

class Paper(SQLModel, table=True):
    __tablename__ = "papers"
    id: UUID = Field(default_factory=uuid4, primary_key=True)
    user_id: UUID = Field(foreign_key="users.id", index=True)

    title: str = Field(index=True)
    authors: List[str] = Field(sa_column=Column(JSON))
    abstract: Optional[str] = None
    toc: Optional[List] = Field(sa_column=Column(JSON))

    file_key: str
    file_url: Optional[str] = None
    source_type: Optional[str] = None
    source_ref: Optional[str] = None

    status: PaperStatus = Field(default=PaperStatus.PENDING)
    error_message: Optional[str] = None

    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)

    chunks: List["PaperChunk"] = Relationship(back_populates="paper")
    summaries: List["PaperSummary"] = Relationship(back_populates="paper")
    layers: List["Layer"] = Relationship(back_populates="paper")
    notes: List["Note"] = Relationship(back_populates="paper")
    mind_map: Optional["MindMap"] = Relationship(back_populates="paper")
    reports: List["Report"] = Relationship(back_populates="paper")
```

### 2.3 向量切片 (PaperChunks)
```python
class PaperChunk(SQLModel, table=True):
    __tablename__ = "paper_chunks"
    id: UUID = Field(default_factory=uuid4, primary_key=True)
    paper_id: UUID = Field(foreign_key="papers.id", index=True)

    content: str
    page_number: Optional[int] = None 
    chunk_index: int

    embedding: List[float] = Field(sa_column=Column(Vector(1536)))
    embedding_model: str
    embedding_dim: int

    paper: Paper = Relationship(back_populates="chunks")
```

### 2.4 收藏夹 (Collections)
```python
class Collection(SQLModel, table=True):
    __tablename__ = "collections"
    id: UUID = Field(default_factory=uuid4, primary_key=True)
    user_id: UUID = Field(foreign_key="users.id", index=True)
    name: str = Field(index=True)
    is_default: bool = Field(default=False)
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)
```

```python
class CollectionPaper(SQLModel, table=True):
    __tablename__ = "collection_papers"
    id: UUID = Field(default_factory=uuid4, primary_key=True)
    collection_id: UUID = Field(foreign_key="collections.id", index=True)
    paper_id: UUID = Field(foreign_key="papers.id", index=True)
    created_at: datetime = Field(default_factory=datetime.utcnow)
```

### 2.5 搜索历史 (SearchHistory)
```python
class SearchHistory(SQLModel, table=True):
    __tablename__ = "search_histories"
    id: UUID = Field(default_factory=uuid4, primary_key=True)
    user_id: UUID = Field(foreign_key="users.id", index=True)
    query: str = Field(index=True)
    filters: Optional[dict] = Field(sa_column=Column(JSON))
    result_count: int = Field(default=0)
    created_at: datetime = Field(default_factory=datetime.utcnow)
```

### 2.6 摘要与报告 (Summary & Report)
```python
class PaperSummary(SQLModel, table=True):
    __tablename__ = "paper_summaries"
    id: UUID = Field(default_factory=uuid4, primary_key=True)
    paper_id: UUID = Field(foreign_key="papers.id", index=True)
    summary_type: str
    content: str
    version: int = Field(default=1)
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)

class Report(SQLModel, table=True):
    __tablename__ = "reports"
    id: UUID = Field(default_factory=uuid4, primary_key=True)
    paper_id: UUID = Field(foreign_key="papers.id", index=True)
    user_id: UUID = Field(foreign_key="users.id", index=True)
    title: str
    type: str
    status: str = Field(default="generating")
    content: Optional[str] = None
    summary: Optional[str] = None
    job_id: Optional[UUID] = Field(index=True)
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)
```

### 2.7 阅读器图层与标注 (Reader)
```python
class Layer(SQLModel, table=True):
    __tablename__ = "layers"
    id: UUID = Field(default_factory=uuid4, primary_key=True)
    paper_id: UUID = Field(foreign_key="papers.id", index=True)
    user_id: UUID = Field(foreign_key="users.id", index=True)
    name: str
    type: str = Field(default="user")
    visible: bool = Field(default=True)
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)

class Annotation(SQLModel, table=True):
    __tablename__ = "annotations"
    id: UUID = Field(default_factory=uuid4, primary_key=True)
    layer_id: UUID = Field(foreign_key="layers.id", index=True)
    type: str
    rects: List[dict] = Field(sa_column=Column(JSON))
    content: Optional[str] = None
    color: Optional[str] = None
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)
```

### 2.8 笔记与脑图 (Notes & MindMap)
```python
class Note(SQLModel, table=True):
    __tablename__ = "notes"
    id: UUID = Field(default_factory=uuid4, primary_key=True)
    paper_id: UUID = Field(foreign_key="papers.id", index=True)
    user_id: UUID = Field(foreign_key="users.id", index=True)
    title: Optional[str] = None
    content: str,
    tags: Optional[List[str]] = None
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)

class MindMap(SQLModel, table=True):
    __tablename__ = "mind_maps"
    id: UUID = Field(default_factory=uuid4, primary_key=True)
    paper_id: UUID = Field(foreign_key="papers.id", index=True)
    user_id: UUID = Field(foreign_key="users.id", index=True)
    graph_data: dict = Field(sa_column=Column(JSON))
    schema_version: int = Field(default=1)
    status: str = Field(default="ready")
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)
```

### 2.10 Agent 会话 (Agent)
```python
class AgentSession(SQLModel, table=True):
    __tablename__ = "agent_sessions"
    id: UUID = Field(default_factory=uuid4, primary_key=True)
    user_id: UUID = Field(foreign_key="users.id", index=True)
    chat_session_id: Optional[UUID] = Field(default=None, foreign_key="chat_sessions.id")
    thread_id: str = Field(index=True)
    agent_type: str
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)

```

### 2.12 统一异步任务 (Jobs)
```python
class Job(SQLModel, table=True):
    __tablename__ = "jobs"
    id: UUID = Field(default_factory=uuid4, primary_key=True)
    user_id: UUID = Field(foreign_key="users.id", index=True)
    paper_id: Optional[UUID] = Field(default=None, foreign_key="papers.id", index=True)
    job_type: str
    status: str = Field(default="pending")
    progress: int = Field(default=0)
    stage: Optional[str] = None
    idempotency_key: str = Field(index=True)
    dependency_ids: Optional[List[str]] = Field(sa_column=Column(JSON))
    payload: Optional[Dict[str, Any]] = Field(sa_column=Column(JSON))
    result_ref: Optional[str] = None
    error_message: Optional[str] = None
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)
    completed_at: Optional[datetime] = None

```
